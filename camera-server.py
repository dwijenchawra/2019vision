#!/usr/bin/python3
import sys
import cv2
import logging
import numpy as np
import math
import imutils 
from enum import Enum
from networktables import NetworkTables
from cscore import CameraServer, VideoSource, UsbCamera

__IP = '10.35.1.2' 
__TABLE_NAME = 'tommyTheTable'
__SUB_TABLE_NAME = 'Front Or Back'
output_stream_front = None
output_stream_back = None

camera_value = None
cs = CameraServer.getInstance()
class TapeFilter:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """
        self.__hsl_threshold_hue = [58.0, 88.0]
        self.__hsl_threshold_saturation = [110.0, 255.0]
        self.__hsl_threshold_luminance = [30.0, 140.0]

        self.hsl_threshold_output = None

        self.__rgb_threshold_red = [0.0, 255.0]
        self.__rgb_threshold_green = [62.0, 255.0]
        self.__rgb_threshold_blue = [0.0, 255.0]

        self.rgb_threshold_output = None

        self.__cv_erode_src = self.rgb_threshold_output
        self.__cv_erode_kernel = None
        self.__cv_erode_anchor = (-1, -1)
        self.__cv_erode_iterations = 0.0
        self.__cv_erode_bordertype = cv2.BORDER_CONSTANT
        self.__cv_erode_bordervalue = (-1)

        self.cv_erode_output = None
        self.__find_contours_input = self.cv_erode_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        self.__hsl_threshold_input = source0
        self.cameraInput = source0
        (self.hsl_threshold_output) = self.__hsl_threshold(self.__hsl_threshold_input, self.__hsl_threshold_hue, self.__hsl_threshold_saturation, self.__hsl_threshold_luminance)

        # Step RGB_Threshold0:
        """
        self.__rgb_threshold_input = source0
        self.cameraInput = source0
        (self.rgb_threshold_output) = self.__rgb_threshold(self.__rgb_threshold_input,
                                                           self.__rgb_threshold_red, self.__rgb_threshold_green, self.__rgb_threshold_blue)
        """

        # Step CV_erode0:
        self.__cv_erode_src = self.hsl_threshold_output
        (self.cv_erode_output) = self.__cv_erode(self.__cv_erode_src, self.__cv_erode_kernel,
                                                 self.__cv_erode_anchor, self.__cv_erode_iterations, self.__cv_erode_bordertype, self.__cv_erode_bordervalue)

        # Step Find_Contours0:
        self.__find_contours_input = self.cv_erode_output
        (self.find_contours_output) = self.__find_contours(
            self.__find_contours_input, self.__find_contours_external_only)

    @staticmethod
    def __hsl_threshold(input, hue, sat, lum):
        """Segment an image based on hue, saturation, and luminance ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max luminance.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (hue[0], lum[0], sat[0]),  (hue[1], lum[1], sat[1]))

    @staticmethod
    def __rgb_threshold(input, red, green, blue):
        """Segment an image based on color ranges.
        Args:
            input: A BGR numpy.ndarray.
            red: A list of two numbers the are the min and max red.
            green: A list of two numbers the are the min and max green.
            blue: A list of two numbers the are the min and max blue.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2RGB)
        return cv2.inRange(out, (red[0], green[0], blue[0]),  (red[1], green[1], blue[1]))

    @staticmethod
    def __cv_erode(src, kernel, anchor, iterations, border_type, border_value):
        """Expands area of lower value in an image.
        Args:
           src: A numpy.ndarray.
           kernel: The kernel for erosion. A numpy.ndarray.
           iterations: the number of times to erode.
           border_type: Opencv enum that represents a border type.
           border_value: value to be used for a constant border.
        Returns:
            A numpy.ndarray after erosion.
        """
        return cv2.erode(src, kernel, anchor, iterations=(int)(iterations + 0.5),
                         borderType=border_type, borderValue=border_value)

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        _, contours, hierarchy = cv2.findContours(
            input, mode=mode, method=method)
        return contours

    def draw_keypoints(self, vis, keypoints, color = (0, 255, 255)):
        for kp in keypoints:
            x, y = kp.pt
            cv2.circle(vis, (int(x), int(y)), 2, color)
    def Nmaxelements(self, list1, N): 
        final_list = [] 
        copy_list = list1
        if len(copy_list) > 0:
            for i in range(0, N):  
                max1 = 0
                for j in range(len(copy_list)):      
                    if copy_list[j] > max1: 
                        max1 = copy_list[j]    
                # modify the code below, this is what is causing the error that occurs         
                if len(copy_list) > 0:        
                    copy_list.remove(max1)
                    final_list.append(max1) 
        return final_list

    def calcDataValue(self, x1, x2, center):
        midpoint = (x1 + x2)/2
        return center - midpoint

    def calcCenter(self, x1, x2, center):
        return (x1 + (x2 - x1)/2) - center

    def absDistance(self, x1, x2):
        return abs(x1 - x2)

    def distance(self, x1, x2, y1, y2):
        dx = math.pow((x2 - x1), 2)
        dy = math.pow((y2 - y1), 2)
        return math.pow((dx + dy), 0.5)        

    def main(self, vid, table):
        print('Creating tapefilter pipeline')
        sys.stdout.flush()
        pipeline = TapeFilter()
        print("test")
        print('Running tapefilter pipeline')
        sys.stdout.flush()
        #have_frame, frame = vid.read()
        img = np.zeros(shape=(160, 120, 3), dtype=np.uint8)  
        time, frame = vid.grabFrame(img, 0.5)
        if frame is not None:
            pipeline.process(frame)
            frame2 = self.draw_keypoints(
                pipeline.cv_erode_output,
                np.array([]),
                (0, 0, 255))
            contours = cv2.findContours(pipeline.hsl_threshold_output, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            contours = imutils.grab_contours(contours)
            #fra3 = cv2.drawContours(frame2, pipeline.find_contours_output, -1, (255,0,255),3)
            contourAreas = []
            data = []
            
            print("Length of contours array: " + str(len(contours)))
            print(contours)

            for i in contours:
                M = cv2.moments(i)
                if M["m00"] == 0:
                    continue
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])
                contourAreas.append(cv2.contourArea(i))
                tupl = (cv2.contourArea(i), (cX, cY))
                #(area, (cx, cy))
                data.append(tupl)

                print("Contour areas: " + str(contourAreas))

                #print(data)
                    #contourAreas.append()
                # show the image
            slist = self.Nmaxelements(contourAreas, 2)
            print("slist     " + str(len(slist)))
            newlist = []
            if(len(data) > 1 and len(slist) > 1 and len(contours) > 1):
                for i in contours:
                    if (len(slist)<2):
                        continue
                    if(cv2.contourArea(i) == slist[0] or cv2.contourArea(i) == slist[1]):
                        cv2.drawContours(frame2, [i], -1, (0, 255, 0), 2)
            if(len(data) > 0 and len(slist) > 0 and len(contours) > 0):
                for i in data:
                    if ((len(i) > 1 and len(slist) > 1) and (i[0] == slist[0] or i[0] == slist[1])):
                        newlist.append(i)
                        cv2.circle(frame2, (i[1][0], i[1][1]), 7, (0, 0, 0), -1)
                        cv2.putText(frame2, "center", (i[1][0] - 20, i[1][1] - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 2)
            print("len newlist" + str(len(newlist)))
            if len(newlist) == 2:
                print(newlist)
                sys.stdout.flush()
                table.putNumber('distance-tapes', self.absDistance(newlist[0][1][0], newlist[1][1][0]))
                table.putNumber('horizontal-distance', self.calcDataValue(newlist[0][1][0], newlist[1][1][0], 260))
                table.putNumber('x1', newlist[0][1][0])
                table.putNumber('x2', newlist[0][1][1])
                table.putNumber('y1', newlist[1][1][0])
                table.putNumber('y2', newlist[1][1][1])
                print('Area1', newlist[0][0])
                print('Area2', newlist[1][0])
                print('Sent Value:', self.calcDataValue(newlist[0][1][0], newlist[1][1][0], 260))
                sys.stdout.flush()
                
                
            output_stream_front.putFrame(frame)

                #print(contours)
                #cv2.imshow('blob detection', frame2)
                #cv2.imshow('FINAL WITH CONTOURS', frame3)
                #cv2.imshow('erode', pipeline.cv_erode_output)
                #cv2.imshow('contours', fra3)
            # print("%s: %s\n%s" % (len(pipeline.find_contours_output), pipeline.find_contours_output, 10*"="))

    #        if cv2.waitKey(1) == 27:  # esc
    #           break

        #cv2.destroyAllWindows()
        output_stream_front.putFrame(frame)
        print('Done.')
        sys.stdout.flush()



#END OF TAPE DETECTION

class BallDetectionPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__hsl_threshold_hue = [0.0, 180.0]
        self.__hsl_threshold_saturation = [248.0, 255.0]
        self.__hsl_threshold_luminance = [21.0, 255.0]

        self.hsl_threshold_output = None

        self.__cv_erode_src = self.hsl_threshold_output
        self.__cv_erode_kernel = None
        self.__cv_erode_anchor = (-1, -1)
        self.__cv_erode_iterations = 1.0
        self.__cv_erode_bordertype = cv2.BORDER_CONSTANT
        self.__cv_erode_bordervalue = (-1)

        self.cv_erode_output = None

        self.__find_contours_input = self.cv_erode_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__filter_contours_contours = self.find_contours_output
        self.__filter_contours_min_area = 4000.0
        self.__filter_contours_min_perimeter = 0.0
        self.__filter_contours_min_width = 0.0
        self.__filter_contours_max_width = 1000.0
        self.__filter_contours_min_height = 0.0
        self.__filter_contours_max_height = 1000.0
        self.__filter_contours_solidity = [44.36450939384295, 100]
        self.__filter_contours_max_vertices = 1000000.0
        self.__filter_contours_min_vertices = 0.0
        self.__filter_contours_min_ratio = 0.0
        self.__filter_contours_max_ratio = 1000.0

        self.filter_contours_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step HSL_Threshold0:
        self.__hsl_threshold_input = source0
        (self.hsl_threshold_output) = self.__hsl_threshold(self.__hsl_threshold_input, self.__hsl_threshold_hue, self.__hsl_threshold_saturation, self.__hsl_threshold_luminance)
        
        # Step CV_erode0:
        self.__cv_erode_src = self.hsl_threshold_output
        (self.cv_erode_output) = self.__cv_erode(self.__cv_erode_src, self.__cv_erode_kernel,
                                                 self.__cv_erode_anchor, self.__cv_erode_iterations, self.__cv_erode_bordertype, self.__cv_erode_bordervalue)

        # Step Find_Contours0:
        self.__find_contours_input = self.cv_erode_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        # Step Filter_Contours0:
        self.__filter_contours_contours = self.find_contours_output
        (self.filter_contours_output) = self.__filter_contours(self.__filter_contours_contours, self.__filter_contours_min_area, self.__filter_contours_min_perimeter, self.__filter_contours_min_width, self.__filter_contours_max_width, self.__filter_contours_min_height, self.__filter_contours_max_height, self.__filter_contours_solidity, self.__filter_contours_max_vertices, self.__filter_contours_min_vertices, self.__filter_contours_min_ratio, self.__filter_contours_max_ratio)


    @staticmethod
    def __hsl_threshold(input, hue, sat, lum):
        """Segment an image based on hue, saturation, and luminance ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max luminance.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (hue[0], lum[0], sat[0]),  (hue[1], lum[1], sat[1]))
        
    @staticmethod
    def __cv_erode(src, kernel, anchor, iterations, border_type, border_value):
        """Expands area of lower value in an image.
        Args:
           src: A numpy.ndarray.
           kernel: The kernel for erosion. A numpy.ndarray.
           iterations: the number of times to erode.
           border_type: Opencv enum that represents a border type.
           border_value: value to be used for a constant border.
        Returns:
            A numpy.ndarray after erosion.
        """
        return cv2.erode(src, kernel, anchor, iterations=(int)(iterations + 0.5),
                         borderType=border_type, borderValue=border_value)

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod
    def __filter_contours(input_contours, min_area, min_perimeter, min_width, max_width,
                        min_height, max_height, solidity, max_vertex_count, min_vertex_count,
                        min_ratio, max_ratio):
        """Filters out contours that do not meet certain criteria.
        Args:
            input_contours: Contours as a list of numpy.ndarray.
            min_area: The minimum area of a contour that will be kept.
            min_perimeter: The minimum perimeter of a contour that will be kept.
            min_width: Minimum width of a contour.
            max_width: MaxWidth maximum width.
            min_height: Minimum height.
            max_height: Maximimum height.
            solidity: The minimum and maximum solidity of a contour.
            min_vertex_count: Minimum vertex Count of the contours.
            max_vertex_count: Maximum vertex Count.
            min_ratio: Minimum ratio of width to height.
            max_ratio: Maximum ratio of width to height.
        Returns:
            Contours as a list of numpy.ndarray.
        """
        output = []
        for contour in input_contours:
            x,y,w,h = cv2.boundingRect(contour)
            if (w < min_width or w > max_width):
                continue
            if (h < min_height or h > max_height):
                continue
            area = cv2.contourArea(contour)
            if (area < min_area):
                continue
            if (cv2.arcLength(contour, True) < min_perimeter):
                continue
            hull = cv2.convexHull(contour)
            solid = 100 * area / cv2.contourArea(hull)
            if (solid < solidity[0] or solid > solidity[1]):
                continue
            if (len(contour) < min_vertex_count or len(contour) > max_vertex_count):
                continue
            ratio = (float)(w) / h
            if (ratio < min_ratio or ratio > max_ratio):
                continue
            output.append(contour)
        return output

    BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')

    def main(self, vid, table):
        '''
        # init network tables
        NetworkTables.initialize(server=__IP)
        table = NetworkTables.getTable(__TABLE_NAME)
        
        
        # init camera
        cs = CameraServer.getInstance()
        cam = UsbCamera('OG Cargo 360', 0)
        cam.setResolution(160, 120)
        cam.setFPS(30)
        cam.setBrightness(20)
        cam.setExposureManual(5)
        cs.startAutomaticCapture(camera=cam)
        vid = cs.getVideo(camera=cam)
        output_stream = cs.putVideo("Cargo Detection", 160, 120)
        '''

        print('Creating pipeline')
        pipeline = BallDetectionPipeline()

        print('Running pipeline')
        img = np.zeros(shape=(160, 120, 3), dtype=np.uint8)
        time, frame = vid.grabFrame(img, 0.5)

        circularities = []
        contours = []
        if frame is not None:
            pipeline.process(frame)
            coordinates = None
            print("processed")
            for contour in pipeline.filter_contours_output:
                contours.append(contour)
                circularities.append(self.findCircularity(cv2.arcLength(contour, True), cv2.contourArea(contour)))
            if len(circularities) > 0:
                finalCircularity = min(circularities)
            print(contours)
            for contour in contours:
                if self.findCircularity(cv2.arcLength(contour, True), cv2.contourArea(contour)) == finalCircularity:
                    M = cv2.moments(contour)
                    if M["m00"] == 0:
                        continue
                    cX = int(M["m10"] / M["m00"])
                    cY = int(M["m01"] / M["m00"])

                    cv2.drawContours(frame, [contour], -1, [255, 0, 0], 2)
                    cv2.circle(frame, (cX, cY), 7, (0, 0, 0), -1)
                    cv2.putText(frame, "center", (cX - 20, cY - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 2)
                    cv2.putText(frame, "center", (cX - 20, cY - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 2)
                    print("test2")
                    print(cv2.contourArea(contour))
                    print((cX, cY))
                    print(260 - cX)
                    #coordinates = (cX, cY)
                    table.putNumber("Area", cv2.contourArea(contour))
                    table.putNumber("CX", cX)
                    table.putNumber("CY", cY)
                    table.putNumber("horizontal-distance-cargo", 316 - cX)
                    if camera_value is not 'BACK':
                        break
            output_stream_back.putFrame(frame)
        
    def findCircularity(self, perimeter, area):
        circularity = (math.pow(perimeter, 2) / (4 * math.pi * area))
        return circularity

#END OF BALL DETECTION

print("main method")
def mainMain():
    NetworkTables.initialize(server=__IP)
    print("nt initialized")
    table = NetworkTables.getTable(__TABLE_NAME)
    subtable = table.getSubTable(__SUB_TABLE_NAME)
    # CAMERA 1
    cam = UsbCamera('Cam 1 Front', 1)
    cam.setResolution(160, 120)
    cam.setExposureManual(0)
    cam.setBrightness(0)
    cam.setFPS(60)
    print("cam1 initialized")
    # CAMERA 2
    cam2 = UsbCamera('Cam 2 Back', 0)
    cam2.setResolution(160, 120)
    cam2.setExposureManual(0)
    cam2.setBrightness(0)
    cam2.setFPS(60)
    print("cam2 initialized")
    # CAMERA 3
    cam3 = UsbCamera('Cam 3 Cargo', 2)
    cam3.setResolution(320, 240)
    cam3.setFPS(30)
    #cam3.setBrightness(20)
    #cam3.setExposureManual(5)
    print("cam3 initialized")

    # EACH CAMERA STARTS CAPTURING VIDEO
    cs.startAutomaticCapture(camera=cam)
    cs.startAutomaticCapture(camera=cam2)
    cs.startAutomaticCapture(camera=cam3)
    
    # GETTING THE VIDEO STREAM OF EACH CAMERA
    vid = cs.getVideo(camera=cam)
    vid2 = cs.getVideo(camera=cam2)
    vid3 = cs.getVideo(camera=cam3)

    tape = TapeFilter()
    ball = BallDetectionPipeline()

    global output_stream_front
    output_stream_front = cs.putVideo('TOP CAMERAS', 160, 120)
    global output_stream_back
    output_stream_back = cs.putVideo('BOTTOM CAMERA', 160, 120)

    print("some success")
    while True:
        camera_value = subtable.getString("value", 'FRONT')
        print(camera_value)       
        
        if camera_value == 'BACK':
            '''
            output_stream = cs.putVideo('Camera Feed', 160, 120)
            TapeFilter.main(vid, table, output_stream)
            '''
            tape.main(vid=vid, table=table)
            continue

        elif camera_value == 'FRONT':
            '''
            output_stream = cs.putVideo('Camera Feed', 160, 120)
            TapeFilter.main(vid, table, output_stream)
            '''
            tape.main(vid=vid2, table=table)
            continue

        else:
            print('error, no camera value detected')
            
if __name__ == "__main__":
    mainMain()