#!/usr/bin/python3
import sys
import cv2
import logging
import numpy as np
import math
import imutils 
from enum import Enum
from networktables import NetworkTables
from cscore import CameraServer, VideoSource, UsbCamera

#   initialize constants for networktables
__IP = '10.35.1.2' 
__SENT_TABLE_NAME = 'tommyTheTable'
__ORIENTATION_TABLE_NAME = 'Front Or Back'

camera_value = None
#get cameraserver instance
cs = CameraServer.getInstance()
class TapeFilter:
    """
    An OpenCV pipeline generated by GRIP.
    This class holds all of the vision processing methods,
    and some of our own implementations as well. 
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """
        self.__hsl_threshold_hue = [58.0, 88.0]
        self.__hsl_threshold_saturation = [110.0, 255.0]
        self.__hsl_threshold_luminance = [30.0, 140.0]

        self.hsl_threshold_output = None

        self.__rgb_threshold_red = [0.0, 255.0]
        self.__rgb_threshold_green = [62.0, 255.0]
        self.__rgb_threshold_blue = [0.0, 255.0]

        self.rgb_threshold_output = None

        self.__cv_erode_src = self.rgb_threshold_output
        self.__cv_erode_kernel = None
        self.__cv_erode_anchor = (-1, -1)
        self.__cv_erode_iterations = 0.0
        self.__cv_erode_bordertype = cv2.BORDER_CONSTANT
        self.__cv_erode_bordervalue = (-1)

        self.cv_erode_output = None
        self.__find_contours_input = self.cv_erode_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        self.__hsl_threshold_input = source0
        self.cameraInput = source0
        (self.hsl_threshold_output) = self.__hsl_threshold(self.__hsl_threshold_input, self.__hsl_threshold_hue, self.__hsl_threshold_saturation, self.__hsl_threshold_luminance)

        # Step CV_erode0:
        self.__cv_erode_src = self.hsl_threshold_output
        (self.cv_erode_output) = self.__cv_erode(self.__cv_erode_src, self.__cv_erode_kernel,
                                                 self.__cv_erode_anchor, self.__cv_erode_iterations, self.__cv_erode_bordertype, self.__cv_erode_bordervalue)

        # Step Find_Contours0:
        self.__find_contours_input = self.cv_erode_output
        (self.find_contours_output) = self.__find_contours(
            self.__find_contours_input, self.__find_contours_external_only)

    @staticmethod
    def __hsl_threshold(input, hue, sat, lum):
        """Segment an image based on hue, saturation, and luminance ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max luminance.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (hue[0], lum[0], sat[0]),  (hue[1], lum[1], sat[1]))

    @staticmethod
    def __cv_erode(src, kernel, anchor, iterations, border_type, border_value):
        """Expands area of lower value in an image.
        Args:
           src: A numpy.ndarray.
           kernel: The kernel for erosion. A numpy.ndarray.
           iterations: the number of times to erode.
           border_type: Opencv enum that represents a border type.
           border_value: value to be used for a constant border.
        Returns:
            A numpy.ndarray after erosion.
        """
        return cv2.erode(src, kernel, anchor, iterations=(int)(iterations + 0.5),
                         borderType=border_type, borderValue=border_value)

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        _, contours, hierarchy = cv2.findContours(
            input, mode=mode, method=method)
        return contours

def draw_keypoints(vis, keypoints, color = (0, 255, 255)):
    """
    This method draws the keypoints generated by the erode method.
    """
    for keypoint in keypoints:
        x, y = keypoint.pt
        cv2.circle(vis, (int(x), int(y)), 2, color)
def Nmaxelements(list1, N): 
    """
    This method finds the two contours with the greatest
    areas and appends them to another list.
    """
    final_list = [] 
    copy_list = list1
    #largest
    index1 = None
    #second largest
    index2 = None
    if len(copy_list) > 0:
        for i in range(0, N):  
            max1 = 0
            for j in range(len(copy_list)):      
                if copy_list[j] > max1: 
                    max1 = copy_list[j]
            # modify the code below, this is what is causing the error that occurs         
            if len(copy_list) > 0:
                if i == 0:
                    index1 = list1.index(max1)
                else:
                    index2 = list1.index(max1)
                copy_list.remove(max1)
                final_list.append(max1) 
    return final_list, index1, index2

'''All the remaining methods just do some calculations we need for getting center values.'''

def calcDataValue(x1, x2, center):
    midpoint = (x1 + x2)/2
    return center - midpoint
def calcCenter(x1, x2, center):
    return (x1 + (x2 - x1)/2) - center
def absDistance(x1, x2):
    return abs(x1 - x2)
def distance(x1, x2, y1, y2):
    dx = math.pow((x2 - x1), 2)
    dy = math.pow((y2 - y1), 2)
    return math.pow((dx + dy), 0.5)  


print("main method")
def mainMain():
    #   network tables initialization
    NetworkTables.initialize(server=__IP)
    print("nt initialized")
    smartdash = NetworkTables.getTable("SmartDashboard")
    table = NetworkTables.getTable(__SENT_TABLE_NAME)
    subtable = smartdash.getSubTable(__ORIENTATION_TABLE_NAME)
    #   initialize cameras
    # CAMERA 1
    cam = UsbCamera('Cam 1 Front', 1)
    cam.setResolution(160, 120)
    cam.setExposureManual(0)
    cam.setBrightness(0)
    cam.setFPS(30)
    print("cam1 initialized")
    # CAMERA 2
    cam2 = UsbCamera('Cam 2 Back', 0)
    cam2.setResolution(160, 120)
    cam2.setExposureManual(0)
    cam2.setBrightness(0)
    cam2.setFPS(30)
    print("cam2 initialized")

    # EACH CAMERA STARTS CAPTURING VIDEO
    cs.startAutomaticCapture(camera=cam)
    cs.startAutomaticCapture(camera=cam2)
    
    # GETTING THE VIDEO STREAM OF EACH CAMERA
    vid = cs.getVideo(camera=cam)
    vid2 = cs.getVideo(camera=cam2)

    tape = TapeFilter()

    #   initialize outputstream, this is the place where we send frames to shuffleboard.
    output_stream = cs.putVideo('TOP CAMERAS', 160, 120)

    print("Running while loop")
    counter = 0
    while True:
        #get front or back value
        camera_value = subtable.getString("value", "FRONT")
        
        #   This condition sends video from different cameras based on the robots orientation.
        if camera_value == 'BACK':
            print("BACK")
            video = vid
        elif camera_value == 'FRONT':
            print("FRONT")
            video = vid2
        else:
            print('error, no camera value detected')
        
        print('Creating tapefilter pipeline')
        sys.stdout.flush()
        pipeline = TapeFilter()
        print('Running tapefilter pipeline')
        sys.stdout.flush()

        #   make a numpy array to store the image in
        img = np.zeros(shape=(160, 120, 3), dtype=np.uint8)
        #   get video
        time, frame = video.grabFrame(img, 0.5)
        if frame is not None:

            """
            This sends the frame though the pipeline and it gets processed,
            generating data for us to work with. 
            """
            pipeline.process(frame)

            #   draws keypoints for contour detection
            frame2 = draw_keypoints(
                pipeline.cv_erode_output,
                np.array([]),
                (0, 0, 255))
            #   finds contours
            image, contours, hierarchy = cv2.findContours(pipeline.hsl_threshold_output, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            contourAreas = []
            data = []
            
            print("Length of contours array: " + str(len(contours)))

            angles = []

            for i in contours:
                #   moments gives us the area and coordinates for the contours
                M = cv2.moments(i)
                if M["m00"] == 0:
                    continue
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])
                contourAreas.append(cv2.contourArea(i))
                angles.append(i)
                tupl = (cv2.contourArea(i), (cX, cY), i)
                #(area, (cx, cy))
                data.append(tupl)

            #   finds the two biggest contours
            slist, index1, index2 = Nmaxelements(contourAreas, 2)
            
            print("len slist     " + str(len(slist)))
            if len(slist) == 2:
                
                # this method draws a rectangle around
                # the rectangular tape for slope measurement
                rect1 = cv2.minAreaRect(angles[index1])
                print("rect 1:     " + str(rect1))
                rect2 = cv2.minAreaRect(angles[index2])
                print("rect 2:     " + str(rect2))

            lrect1 = list(rect1)
            lrect2 = list(rect2)

            # rounding slopes so we don't 
            # have to deal with erratic values.
            if lrect1[2] > -30 and lrect1[2] < -5:
                lrect1[2] = 10
            if lrect2[2] > -60 and lrect1[2] < -95:
                lrect2[2] = 80
            
            
            newlist = []
            if(len(data) > 1 and len(slist) > 1 and len(contours) > 1):
                for i in contours:
                    if (len(slist) < 2):
                        continue
                    if(cv2.contourArea(i) == slist[0] or cv2.contourArea(i) == slist[1]):
                        cv2.drawContours(frame, [i], -1, (0, 255, 0), 1)
            if(len(data) > 0 and len(slist) > 0 and len(contours) > 0):
                for i in data:
                    if ((len(i) > 1 and len(slist) > 1) and (i[0] == slist[0] or i[0] == slist[1])):
                        newlist.append(i)
                        cv2.circle(frame, (i[1][0], i[1][1]), 2, (0, 0, 0), -1)
                        cv2.putText(frame, "center", (i[1][0] - 20, i[1][1] - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 255), 1)
                        cv2.putText(frame, "1", (int(lrect1[0][0]), int(lrect1[0][1])), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (45, 34, 255), 1)
                        cv2.putText(frame, "2", (int(lrect2[0][0]), int(lrect2[0][1])), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (45, 34, 255), 1)


            

            # Underneath, we send values to networktables for the roborio to access and act upon
            if len(newlist) == 2:
                # This condition basically tells us if we are
                # looking at one pair of matching vision tapes
                #    X COORD        X COORD          SLOPE       SLOPE  
                if lrect1[0][0] < lrect2[0][0] and lrect1[2] < lrect2[2]:
                    table.putNumber('distance-tapes', absDistance(newlist[0][1][0], newlist[1][1][0]))
                    table.putNumber('horizontal-distance', calcDataValue(newlist[0][1][0], newlist[1][1][0], 80))
                    table.putNumber('x1', newlist[0][1][0])
                    table.putNumber('x2', newlist[0][1][1])
                    table.putNumber('y1', newlist[1][1][0])
                    table.putNumber('y2', newlist[1][1][1])
                    table.putNumber('canSeeTape?', True)
                    print('Area1', newlist[0][0])
                    print('Area2', newlist[1][0])
                    print('Sent Value:', calcDataValue(newlist[0][1][0], newlist[1][1][0], 260))
                    sys.stdout.flush()
                    cv2.putText(frame, "good", (70, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (45, 34, 255), 1)
                elif lrect2[0][0] < lrect1[0][0] and lrect2[2] < lrect1[2]:
                    table.putNumber('distance-tapes', absDistance(newlist[0][1][0], newlist[1][1][0]))
                    table.putNumber('horizontal-distance', calcDataValue(newlist[0][1][0], newlist[1][1][0], 80))
                    table.putNumber('x1', newlist[0][1][0])
                    table.putNumber('x2', newlist[0][1][1])
                    table.putNumber('y1', newlist[1][1][0])
                    table.putNumber('y2', newlist[1][1][1])
                    table.putNumber('canSeeTape?', True)
                    print('Area1', newlist[0][0])
                    print('Area2', newlist[1][0])
                    print('Sent Value:', calcDataValue(newlist[0][1][0], newlist[1][1][0], 260))
                    sys.stdout.flush()
                    cv2.putText(frame, "good", (70, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (45, 34, 255), 1)
                else:
                    print("bad slopes :(")
                    table.putNumber('canSeeTape?', False)
                    cv2.putText(frame, "bad", (70, 100), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (45, 34, 255), 1)
            else:
                print("there weren't two contours")
                table.putNumber('canSeeTape?', False)
            print("sending frame")
            # send frame to shuffleboard
            output_stream.putFrame(frame)

        print('Done.')
        sys.stdout.flush()
        #just counting how fast it is running and if it is running at all
        counter += 1
        print(counter)

#END OF TAPE DETECTION

if __name__ == "__main__":
    mainMain()
